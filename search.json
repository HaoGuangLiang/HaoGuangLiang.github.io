[{"title":"Hello World","url":"/2025/12/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\n        \n          Quick Start\n      \n        \n          Create a new post\n      $ hexo new &quot;My New Post&quot;\n\nMore info: Writing\n\n        \n          Run server\n      $ hexo server\n\nMore info: Server\n\n        \n          Generate static files\n      $ hexo generate\n\nMore info: Generating\n\n        \n          Deploy to remote sites\n      $ hexo deploy\n\nMore info: Deployment\n"},{"title":"使用hexo + GitHub部署自己的博客","url":"/2025/12/13/%E4%BD%BF%E7%94%A8hexo%20+%20GitHub%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E4%BD%BF%E7%94%A8hexo%20+%20GitHub%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","content":"Hexo是一个博客框架，Hexo生成自己的博客项目，可以将的html、Markdown文件解析生成可部署的静态网页。\nHexo有很多漂亮的主题供选择，配置后就可以生成对应主题的静态项目。\n官方文档链接：\n\nHexo中文官网\n\nhexo主题stun\n\n\n\n        \n          环境准备\n      安装 Hexo 相当简单，只需要先安装下列应用程序即可：\n\nNode.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n\nGit\n\n\n如果你的电脑上恰好拥有这些必备程序，那么恭喜你，可以直接前往安装hexo了\n\n        \n          node版本限制\n      20.19.0及以上版本都可以使用最新的hexo，否则只能使用旧的hexo版本了\n\n        \n          安装Hexo\n      \n        \n          全局安装Hexo\n      新手推荐，可以在任意位置直接使用hexo命令\nnpm install -g hexo-cli\n\n\n        \n          局部安装Hexo\n      对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。\nnpm install hexo\n\n局部安装的方式使用时需要在hexo命令的前面加一个npx就可以使用hexo命令npx hexo &lt;command&gt;\n\n        \n          使用Hexo创建博客项目，并启动项目\n      安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\n# 创建一个my-blog项目hexo init my-blog# 进入my-blog项目文件夹cd my-blog# 安装项目的依赖文件npm install\n\n此时我们的博客项目就初始化完成了，我们可运行博客项目查看效果\n如果想要了解项目的结构可以都这里查看Hexo初始化的项目结构\n# 进入博客项目根目录，然后执行下面启动服务的命令运行博客项目hexo server\n\n启动成功后会输出项目访问地址：http://localhost:4000/，我们直接在浏览器打开就能看到博客主页了\n\n这里我们在访问时发现页面加载很慢，其实是一些css、js使用的cdn链接，这些文件会出现加载慢或加载失败。解决方式见这里博客第一次启动后发现页面加载很慢的问题。\n目前博客的样式是默认样式，下面内容会演示通过使用主题的方式美化我们的博客。\n下面内容还会将博客推送到GitHub，推送后我们可以使用GitHub提供的链接在公网访问到我们的博客了。\n\n        \n          Hexo的项目结构\n      .├── _config.yml  ├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes\n\n\n        \n          _config.yml\n      网站的 配置 文件。 您可以在此配置大部分的参数。\n\n        \n          package.json\n      项目的包管理文件，项目中用到的依赖都在这里配置\n应用程序的信息。 EJS, Stylus 和 Markdown 渲染引擎 已默认安装，您可以自由移除。 如果您想，可以稍后卸载它们。\npackage.json&#123;  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;hexo&quot;: &quot;^7.0.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^2.0.0&quot;,    &quot;hexo-generator-category&quot;: &quot;^2.0.0&quot;,    &quot;hexo-generator-index&quot;: &quot;^3.0.0&quot;,    &quot;hexo-generator-tag&quot;: &quot;^2.0.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^3.0.0&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^6.0.0&quot;,    &quot;hexo-server&quot;: &quot;^3.0.0&quot;,    &quot;hexo-theme-landscape&quot;: &quot;^1.0.0&quot;  &#125;&#125;\n\n\n        \n          scaffolds\n      模版 文件夹。 当您新建文章（markdown）时，Hexo 会根据 scaffold 来创建文件。\n\n        \n          source\n      资源文件夹。 是存放用户资源的地方。 除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。 Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\n\n        \n          themes\n      主题 文件夹。 Hexo 会根据主题来生成静态页面\n\n        \n          博客的国际化\n      修改Hexo根目录下_config.yml，把博客修改为中文\nlanguage: zh-CN\n\n\n        \n          创建文章\n      新创建的文章会被存储在Hexo项目根目录的\\source_posts下\nhexo new 文章标题\n\n\n        \n          博客的美化\n      我这边使用的是stun这个主题，如果你想使用其他主题的话也可以去[Hexo主题官网](Themes | Hexo)找自己喜欢的主题\n\n        \n          stun主题的安装与使用\n      安装主题，在 Hexo 根目录下，执行指令：\n# 从github克隆项目到themes/stun文件夹git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun\n\n安装主题所需的依赖hexo-renderer-pug，在 Hexo 根目录下，执行指令\nnpm install --save hexo-renderer-pug\n\n使用主题stun，修改 Hexo 根目录下的 _config.yml 文件：\ntheme: stun\n\n启动Hexo项目\n# 清理项目并启动服务hexo clean &amp;&amp; hexo s\n\n此时博客主题的初步使用已经完成了，访问链接查看效果\n\n\n        \n          配置博客主题\n      [stun主题配置文档]\n\n        \n          网站主体设置\n      body:  # 网站主体背景图片  bg_image:    enable: false    # 填写图片路径或链接    url: https://xxxxx.png    # 是否固定背景图片（相当于设置 CSS 属性 position: fixed）    fixed: true    # 是否重复显示背景图片（相当于设置 CSS 属性 background-repeat: repeat/no-repeat）    repeat: false  # 网站主体背景图片的遮罩效果  mask:    enable: false    # 透明度（取值：0 ~ 1）    opacity:      # 默认情况下，网站主体背景图片的透明度      default: 0.1      # 夜晚模式下，网站主体背景图片的透明度      night_mode: 0.6\n\n\n        \n          作者信息\n      author:  enable: true  # 侧边栏头像  avatar:    # 填写图片路径或链接    url: https://xxxxx.png    # 是否显示为圆形    rounded: true    # 头像透明度（取值：0 ~ 1）    opacity: 1    # 鼠标经过时的动画，可选值：turn 或 shake    animation: turn  # 格言（可以是任意一句想写的话）  motto: hello world\n\n我这里修改了网站嘴上面的背景图片和头像就有了这样的效果\n\n这个主题的把部分都是可以配置的，其他的一些配置可以到官网去看看[stun主题配置文档]\n\n        \n          顶部导航栏增加新页面\n      \n        \n          启用分类页、标签页\n      Stun 主题内置有：分类页、标签页。默认没有启用。如果想启用它们，你需要执行以下步骤：\n\n创建页面，在Hexo项目根目录执行\n# 启用分类页，执行这条指令\nhexo new page categories\n\n# 启用标签页，执行这条指令\nhexo new page tags\n\n\n修改 Front-Matter在 Hexo 根目录下，找到 source/categories 或 source/tags 文件夹中的 Markdown 文件，设置 Front-Matter：\n---# 如果是分类页，设置这个type: &quot;categories&quot;# 如果是标签页，设置这个type: &quot;tags&quot;---\n\n修改主题配置文件将 categories 或 tags 对应项取消注释：\n# `||` 分隔符之前是页面路径，`||` 分隔符之后是图标# 用法（有图标）: `Key: /路径/ || fa(s|r|l|d|b) fa-图标名称`# 用法（无图标）: `Key: /路径/`# fas far fal fad fab 是 FontAwesome 5.x 中图标的前缀，你需要根据具体图标自行设置# 查找图标名称，请访问：https://fontawesome.com/iconsmenu:  home: / || fas fa-home  archives: /archives/ || fas fa-folder-open  # categories: /categories/ || fas fa-layer-group  # tags: /tags/ || fas fa-tags\n\n我们新增的分类页、标签页在打开时我们会发现里面是没有任何分类和标签的，我们只需要在编写markdown时在头部加入一些标签和分类信息，我们的分类和标签页就可以显示出已经使用的标签和分类了给文章添加分了和标签\n---title: ./// 添加分类 前端技术和后端技术是同级，前端技术和hexo上下级关系categories:    - [前端技术,   hexo]    - 后端技术// 添加标签，标签部分层级tags:    - 前端技术    - hexo    - GitHub    - 个人博客---\n\n\n        \n          新增自定义页面\n         以添加一个阅读页面为例\n\n修改主题配置文件\nmenu:  reading: /reading/ || fas fa-book\n\n生成页面文件\n# 这里的 reading 对应上一步你设置的路径名称hexo new page reading\n\n国际化设置找到 languages 目录下的语言文件，根据你网站使用的语言选择对应的语言文件，例如：zh-CN.yml：\nmenu:  reading: 阅读\n\n这样就添加好了自定义页面。另外，你可以通过修改主题配置文件里的 menu_settings 选项，来设置图标和文字是否显示：\nmenu_settings:  # 是否只显示图标  icon_only: false  # 是否只显示文字  text_only: false\n\n\n        \n          新增完页面后的效果\n      \n\n        \n          通过custom.css调整主题样式\n      在Hexo项目根目录下的themes\\stun\\source\\css文件夹custom.css文件，直接在这个文件内编写css，也可以对主题的页面样式进行调整然后修改主题的配置文件_config.yml\ncss_custom: /css/custom.css\n\n\n        \n          将博客发布到GitHub\n      \n安装 hexo-deployer-git。\n# hexo根目录执行，安装插件并加入package.json中npm install hexo-deployer-git install --save\n\n在 _config.yml 中添加以下配置（如果配置已经存在，请将其替换为如下）bash\ndeploy:  type: git  repo: https://github.com/&lt;username&gt;/&lt;project&gt;  branch: gh-pages\n\n并在自己的github中创建一个的仓库\n\n执行 hexo clean &amp;&amp; hexo deploy 。\n\n浏览 username.github.io&#x2F;，检查你的网站能否运作。\n\n\n\n        \n          遇到的一些问题\n      \n        \n          博客第一次启动后发现页面加载很慢的问题\n      解决方案就是，把加载慢的js下载到本地，放到项目中，然后我们会发现项目加载飞快\n在浏览器中打开博客页面，然后浏览器中按F12打开控制台，我们看那些文件加载的很慢，这些文件大概率都是使用的cdn，这些就是我们要处理的问题\n\n以jquery.min.js为例：\n打开Hexo项目根目录下面的themes\\stun\\_config.yml主题的配置文件，搜索jquery.min.js\n\n然后修改为\njquery: /js/jquery.min.js\n\n将jquery下载下来下来，放在themes\\stun\\source\\js目录下，直接访问注释中提供的cnd或者自己去网上找对应版本的js\n根据此步骤吧其他几个加载慢的也这样处理一下，我们发现博客页面就可以秒开了，custom.css不用管，如果想要了解可以到通过custom.css调整主题样式去查看\n\n        \n          图片问题\n      在使用过程中，本地图片在Hexo项目中显示是有问题的，文章中使用相对路径显示的图片都没有办法显示\n解决方法：\n修改Hexo的配置文件config.yml\npost_asset_folder: true\n\n修改之后，我们在使用hexo new命令创建文章时，会自动在同级目录创建一个与文章名相同的文件夹，将图片放入文件夹，然后文章中使用相对路径来访问图片，hexo就可以正确的处理图片的显示问题\n","categories":["前端技术","hexo"],"tags":["前端技术","hexo","GitHub","个人博客"]},{"title":"腾讯云代码助手CodeBuddy","url":"/2025/12/23/%E8%85%BE%E8%AE%AF%E4%BB%A3%E7%A0%81%E5%8A%A9%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/%E8%85%BE%E8%AE%AF%E4%BB%A3%E7%A0%81%E5%8A%A9%E6%89%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","content":"\n        \n          腾讯云代码助手CodeBuddy常用功能\n      官网地址：https://cloud.tencent.com/document/product/1749/104236\n\n        \n          CodeBuddy与腾讯同款插件对比\n      \n\n\n赋能多样开发场景\nCodeBuddy 插件\nCodeBuddy IDE\nCodeBuddy Code\n\n\n\n需求用户\n日常编码开发者 &#x2F; 特定 IDE 使用者\n产品 &#x2F; 设计师 &#x2F; 全栈开发 &#x2F; 编程初学者\nDevOps &#x2F; 运维 &#x2F; SRE &#x2F; 资深开发者\n\n\n核心优势\n即插即用零成本学习无缝融入现有工作流轻量级资源占用\n产设研一体工作台腾讯生态集成：CloudBase &#x2F; EdgeOne Pages &#x2F; Cloudstudio可视化调试\n系统级操作：Shell &#x2F; 文件 &#x2F; 网络无头环境支持任务编排能力：需求规划 &#x2F; Sub Agent\n\n\n应用场景\n日常效率提升单 &#x2F; 多文件日常编码语法补全快速注释生成\n0-1 沉浸式编码辅助快速原型 MCP 开发设计稿转代码复杂业务逻辑可视化开发，交互调试\n复杂业务的自动化无头环境的编码自动化CI &#x2F; CD 部署与运维闭环复杂项目批量重构\n\n\n\n        \n          核心功能\n      智能补全代码信息\n腾讯云代码助手可以对 IDE 中的业务代码进行全面解析，在随后的代码编程中进行自动补全。上下文的代码质量越高、内容越丰富，补全的代码信息越准确。\n精准修复错误代码\n腾讯云代码助手可以快速检查代码中的语法错误和逻辑错误，帮助开发者规范代码格式。\n清晰解释既有代码\n当开发者需要处理别人的代码，或者在既有代码中进行延展开发时，可以通过腾讯云代码助手快速理解初始代码，降低理解成本。\n按需生成单元测试\n腾讯云代码助手会根据函数、方法、内容逻辑生成相关的测试代码，快速实现单元测试。\n智能审查本地代码\n腾讯云代码助手推出智能评审辅助的功能，开发者能够在项目开发过程中及时发现并解决本地代码变更可能引入的问题，从而提高代码质量，加速开发流程。\n清晰理解工程代码\n腾讯云代码助手提供 @workspace 和 #Codebase 能力，开发者可以对工程进行提问，能够帮助开发者快速获取与整个代码仓库相关的问题答案。不管是对代码结构、函数和类关系、项目工程依赖，还是复杂的代码逻辑和业务流程有疑问，都能够提供精确且与上下文相关的解答。\n人工智能技术对话\n腾讯云代码助手将对话问答功能与 IDE 进行了集成打通；开发者可以随时随地，以各种方式向腾讯云代码助手进行技术对话咨询，所获取的代码内容可以一键插入编辑器当中。\n支持自定义指令\n通过设置自定义指令，开发者可以快速调用常用的代码片段或函数，避免重复输入和查找；同时，自定义指令功能允许用户调整 AI 的响应方式，使其更符合个人的编程风格和习惯；最后，可以帮助团队成员保持一致的编码风格和规范，有助于提高代码的可读性和可维护性。\n支持创建 RAG 知识库\n腾讯云代码助手支持企业构建专属的知识库，在提供研发问答和智能编码服务时，更加精准、全面，有效增强了模型输出的效果，助力开发者高效解决问题，提升编码效率。\n支持对话大模型接入和切换\n腾讯云代码助手除了支持腾讯自研的混元大模型之外，也支持其它例如 DeepSeek 大模型的接入，有效提升了对话的理解，帮助开发者实现更加强大、高效、安全的 AI 编程体验。\n\n        \n          主要功能\n      \n        \n          IDEA\n      \n        \n          技术对话功能\n      代码助手对话面板与传统的聊天软件类似，只是开发者只能与代码助手进行对话，并且只能咨询一些有关编程技术的问题。对话面板适合咨询一些比较宽泛的问题，一些复杂的问题，需要开发者多回合沟通才能得到最终答案，并且答案的形式是纯文字或者是代码 + 文字说明等形式。\n\n        \n          代码补全功能\n      目前支持的主流开发语言的补全，例如：C、C++、CSS、Go、HTML、Java、JavaScript、Kotlin、TypeScript、React、Python、SQL、Markdown 等。只需要使用编辑器打开代码文件，编辑代码文件时候，代码助手会在合适时机和位置自动触发智能代码补全提示。\n\n        \n          快捷键\n      默认快捷键如下：\n\n\n\n操作\nWindows\n\n\n\n触发代码补全\nEnter\n\n\n采纳所有推荐代码\nTab\n\n\n按行采纳\nAlt + l\n\n\n按此采纳\nAlt + W\n\n\n手动触发推荐\nAlt + P\n\n\n撤销当前推荐状态\nEsc\n\n\n经过尝试感觉不好用，尤其是官方的文档中好多功能与快捷键，并不像官方文档中描述的可用，也可能是我的版本没有安装正确，代码提示倒是挺好用的。\n","categories":["前端技术","hexo","后端技术"],"tags":["前端技术","hexo","GitHub"]},{"title":"正则表达式常用语法","url":"/2025/12/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/","content":"\n        \n          正则表达式修饰符\n      \n\n\n修饰符\n描述\n\n\n\ni\n不区分大小写\n\n\ng\n执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。\n\n\nm\n执行多行匹配\n\n\n\n        \n          特殊字符\n      \n\n\n特别字符\n描述\n\n\n\n$\n匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用\\$。\n\n\n^\n匹配输入字符串的开始位置，如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。若果在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。\n\n\n( )\n标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。\n\n\n*\n匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。\n\n\n+\n匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。\n\n\n.\n匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。\n\n\n[\n标记一个中括号表达式的开始。要匹配 [，请使用 [。\n\n\n?\n匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。\n\n\n\\\n将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。\n\n\n{\n标记限定符表达式的开始。要匹配 {，请使用 {。\n\n\n|\n指明两项之间的一个选择。要匹配 |，请使用 \\\n\n\n*** 和 + 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。**限定符\n\n        \n          () 圆括号使用说明：\n      () 表示捕获分组，() 会把每个分组里的匹配的值保存为一个数据，下标0是整个正则匹配到的内容，下标大于0对应第几个括号内正则捕获到的内容\n\n()中使用了限定符&#x2F;g，会导致正则中的括号不储存捕获到的内容\n\n但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 ?: 放在第一个选项前来消除这种副作用。\n其中 ?: 是非捕获元之一，还有两个非捕获元是 ?&#x3D; 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。\n从图中可见第一个括号没有捕获内容，只有第二个括号捕获的内容\n\n\n        \n          以下列出圆括号中 ?&#x3D;、?&lt;&#x3D;、?!、?&lt;! 的使用区别\n      这几种正则表达式，捕获时都不会存储括号中的值\n\n\n        \n          ?&#x3D;，exp1(?&#x3D;exp2)：查找 exp2 前面的 exp1。\n      \n?&lt;&#x3D;，(?&lt;&#x3D;exp2)exp1：查找 exp2 后面的 exp1。\n\n        \n          ?!，exp1(?!exp2)：查找后面不是 exp2 的 exp1。\n      \n\n        \n          ?&lt;!，(?&lt;!exp2)exp1：查找前面不是 exp2 的 exp1。\n      \n\n\n        \n          限定符\n      \n\n\n*\n匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于 {0,}。\n\n\n\n+\n匹配前面的子表达式一次或多次。例如，zo+ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。\n\n\n?\n匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 “do” 、 “does”、 “doxy” 中的 “do” 和 “does”。? 等价于 {0,1}。\n\n\n{n}\nn 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 “Bob” 中的 o，但是能匹配 “food” 中的两个 o。\n\n\n{n,}\nn 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 “Bob” 中的 o，但能匹配 “foooood” 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。\n\n\n{n,m}\nm 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 “fooooood” 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。\n\n\n\n        \n          定位符\n      \n\n\n字符\n描述\n\n\n\n^\n匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。\n\n\n$\n匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。\n\n\n\\b\n匹配一个单词边界，即字与空格间的位置。\n\n\n\\B\n非单词边界匹配。\n\n\n","categories":["前端技术","正则表达式"],"tags":["前端技术","正则表达式"]},{"title":"Git学习","url":"/2025/12/24/Git%E5%AD%A6%E4%B9%A0/Git%E5%AD%A6%E4%B9%A0/","content":"\n        \n          Git的学习\n      分布式的版本控制系统，代码被放在每个人的电脑，用户之间可以直接同步代码。\n集中式的版本控制器，同步代码放在一台特定的电脑，同步时只能通过这台电脑同步。\n集中式缺点，主服务器一旦宕机，每个人都同步不了代码了。 \n\n        \n          安装Git\n      \n        \n          Windows\n      在Windows上使用Git，有两种安装方法。\n第一种:\n直接从Git官网直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功。\n第二种：\n先安装一个包管理器，推荐Scoop，然后在PowerShell中通过以下命令安装Git：\n等我学习完Scoop之后在搞\n\n        \n          配置Git\n      因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\ngit config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot;\n\n\n        \n          创建版本库\n      什么是版本库呢？版本库又名仓库（Repository），你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n创建一个版本库非常简单，首先，创建一个空目录：\n# 创建一个learngit目录，并进入改目录mkdir learngit cd learngit\n\n创建一个版本库\ngit initInitialized empty Git repository in D:/project/study/learngit/.git/\n\n我们创建了一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。\n也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。\n注意：如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\n\n        \n          把文件添加到版本库\n      首先 现在我们编写一个readme.txt文件，文件内容如下：\nGit is a version control system.Git is free software.\n\n一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。\n使用Windows的童鞋要特别注意：千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Visual Studio Code代替记事本，不但功能强大，而且免费！\n然后，用命令git add告诉Git，把文件添加到仓库：\ngit add readme.txt\n\n执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。\n最后，用命令git commit告诉Git，把文件提交到仓库：\ngit commit -m &quot;wirite a readne file&quot;[master (root-commit) 8e66d00] wirite a readne file 1 file changed, 2 insertions(+) create mode 100644 readme.txt\n\n-m后面跟的是本次的提交备注，然后提示一个文件改变，插入的2行。\n为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\ngit add file1.txtgit add file2.txt file3.txtgit commit -m &quot;add 3 files.&quot; \n\n\n        \n          时光机穿梭\n      \n        \n          查看修改\n      \n        \n          查看仓库状态\n      可以查看仓库中那些文件被修改，被添加，被删除\ngit status\n\n下面我们演示一下如何查看状态，我们继续修改readme.txt文件，改成如下内容：\nGit is a distributed version control system.Git is free software.\n\n现在，运行git status命令看看结果：\ngit statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)        modified:   readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n\n此时可以看到readme.txt文件已经被修改，git status只会告诉我们修改了哪些文件，不会告诉我们修改了哪些具体信息\n\n        \n          对比差异\n      可以查看文件具体修改了什么内容\ngit diff readme.txt\n\n我们执行一下命令查看结果\ngit diff readme.txtdiff --git a/readme.txt b/readme.txtindex d8036c1..013b5bc 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software.\\ No newline at end of file\n\n可以看到结果提示我们在readme.txt文件中我们增加了一个单词distributed \n此时我们把修改提交到git\ngit add readme.txt\n\n再次查查看文件状态\ngit statusOn branch masterChanges to be committed:  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)        modified:   readme.txt\n\n结果告诉我们修改了readme.txt，接下来我们就可以放心的提交了\ngit commit -m &quot;add distributed&quot;[master be20317] add distributed 1 file changed, 1 insertion(+), 1 deletion(-)\n\n提交之后我们可以再看看文件的状态\ngit statusOn branch masternothing to commit, working tree clean\n\n此时我们能看到，没有任何修改了\n\n        \n          版本回退\n      现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：\nGit is a distributed version control system.Git is free software distributed under the GPL.\n\n然后尝试提交：\ngit add readme.txtgit commit -m &quot;append GPL&quot;[master 7b41b8a] append GPL 1 file changed, 1 insertion(+), 1 deletion(-)\n\n每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。\n现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：\n版本1：wrote a readme file\nGit is a version control system.Git is free software.\n\n版本2：add distributed\nGit is a distributed version control system.Git is free software.\n\n版本3：append GPL\nGit is a distributed version control system.Git is free software distributed under the GPL.\n\n当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：\n\n        \n          查看已提交的修改记录\n      git logcommit 07b577a4e8f3161421491c424128e29abca864de (HEAD -&gt; master)Author: HaoGuangLiang &lt;h15737811708@163.com&gt;Date:   Wed Jan 7 11:05:43 2026 +0800    append GPLcommit be203179ebf3c396ada1911b339ecce2cc913b2dAuthor: HaoGuangLiang &lt;h15737811708@163.com&gt;Date:   Wed Jan 7 10:58:38 2026 +0800    add distributedcommit 8e66d00af5ef69c97e5f05afbae46a53330787b2Author: HaoGuangLiang &lt;h15737811708@163.com&gt;Date:   Wed Jan 7 10:48:13 2026 +0800    wirite a readne file\n\ncommit 后面跟的是commit_id是提交记录id\n如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：\ngit log --pretty=oneline07b577a4e8f3161421491c424128e29abca864de (HEAD -&gt; master) append GPLbe203179ebf3c396ada1911b339ecce2cc913b2d add distributed8e66d00af5ef69c97e5f05afbae46a53330787b2 wirite a readne file\n\n\n        \n          回退到上一个版本\n      现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？\n首先，必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交07b577...（注意我的提交ID和你的肯定不一样，回退上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\ngit reset --hard HEAD^# 或git reset --hard HEAD~1\n\n--hard参数有啥意义？--hard会回退到上个版本的已提交状态，而--soft会回退到上个版本的未提交状态，--mixed会回退到上个版本已添加但未提交的状态。\n我在window11执行下面命令时发现并没有执行成功，可以再输入^然后回车，就好了\ngit reset --hard HEAD^More? ^HEAD is now at be20317 add distributed\n\n因为转义原因^^第一个^会被当做转义符，所以^^被转义后就相当于^\n我们可以使用cat命令查看一下文件内容\ncat readme.txtGit is a distributed version control system.Git is free software.\n\n此时我们发现，文件的内容已经被还原\n我们使用git log命令查看一下提交记录\ncommit 5eef1c8f12dfb0ee88ec8a901725bbae7bc2a0d4 (HEAD -&gt; master)Author: HaoGuangLiang &lt;h15737811708@163.com&gt;Date:   Wed Dec 24 14:45:43 2025 +0800    append GPLcommit 71e833da5fb983b2c8c57c9889b19e5e21e443fcAuthor: HaoGuangLiang &lt;h15737811708@163.com&gt;Date:   Wed Dec 24 14:04:33 2025 +0800    wrote a readme file\n\n此时我们发现之前最新的一条提交记录不见了，最新的提交记录变成了append GPL\n如果此时我们还想要回到之前最新的版本，在窗口未关闭的情况下我们可以在上面找到之前提交记录的commid id，再切换到这个版本\ngit reset --hard b41a923f7\n\n然后我们查看一下文件内容，文件内容又回到的最新的版本，这里我们提交记录id并不用写完，只需要写一部分git就能自己找到，但是也不能太短，不然找到多条提交记录，git也是不知道切换到哪里\n此时我们可以在查看一下文件内容\ncat .\\readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.\n\n\n        \n          查看历史执行命令\n      如果窗口已经关闭了怎么才能回退到到最新的版本，我们必须找到最新的提交记录id，git提供了git reflog查看每一次执行命令的记录\ngit reflogbe20317 (HEAD -&gt; master) HEAD@&#123;5&#125;: reset: moving to HEAD^07b577a HEAD@&#123;6&#125;: commit: append GPLbe20317 (HEAD -&gt; master) HEAD@&#123;7&#125;: commit: add distributed8e66d00 HEAD@&#123;8&#125;: commit (initial): wirite a readne file\n\n每一条开头我们都能看到命令执行后的版本号\n此时使用git reset --hard 提交记录id命令就可以切换到对应的分支了\n\n        \n          小结\n      我们由此可以发现，每次进行版本回退，并不会导致我们之前已经提交的修改消失。就好像各种版本都被存放了一份，只不过我们可以来回切换不同的版本一样。\n\n        \n          工作区和暂存区\n      \n\n        \n          工作区（Working Directory）\n      就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区\n\n        \n          版本库（Repository）\n      工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。\n\n        \n          暂存区\n      Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\ngit add把文件添加进去，实际上就是把文件修改添加到暂存区；\ngit commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n        \n          管理修改\n      Git跟踪的是修改而非文件，修改指的是编辑文件、添加文件、修改文件、删除文件。\n接下来我们用一个例子说明一下：\n在readme.txt添加一行文本：\nAdd a line for the first time.\n\n将修改提交到暂存区\ngit add readme.txt\n\n再次修改readme.txt文件，添加一行\nAdd a line for the second time.\n\n使用git status查看修改状态\ngit statusOn branch masterChanges to be committed:  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)        modified:   readme.txtChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)        modified:   readme.txt\n\n把修改提交到版本库\ngit commit -m &quot;commit modify row&quot;\n\n我们再次查看修改状态\ngit statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)        modified:   readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n\n可以发现，我们提交了readme.txt文件之后，提交了暂存区的修改，而不是提交了修改的文件。\n\n        \n          撤销修改\n      \n        \n          丢弃工作区修改\n      使用git checkout命令可以撤销修改，只能撤销已修改但没有放到暂存区的修改\ngit checkout -- readme.txt\n\n\n        \n          暂存区修改回退到工作区\n      将放到暂存区的代码撤回到已修改未放到暂存区的状态，也就是从暂存区退回到的工作区\ngit reset HEAD readme.txt\n\n此时我们就可以使用git checkout -- readme.txt在丢弃掉工作区的修改了。\n如果想要退回版本，只能使用之前学习的回退版本的命令git reset --hard HEAD~1\n\n        \n          删除文件\n      假如我们删除了一个文件test.txt，这个文件之前被提交到了版本库。\n这个时候一般会出现两种情况\n第一种：我们想要把该文件从版本库从版本库移除，可以使用下面命令\ngit rm test.txt\n\n然后我们再提交修改\ngit commit -m &quot;del test.txt&quot;\n\n此时版本库中文件就删除成功了\n 提示，先手动删除文件，然后使用git rm &lt;file&gt;和git add&lt;file&gt;效果是一样的。\n第二种：我们误删了，想要恢复\ngit checkout -- test.txt\n\n从来没有被添加到版本库就被删除的文件，是无法恢复的！\n\n        \n          远程仓库\n      \n        \n          GitHub\n      \n        \n          GitHub配置ssh\n      SSH (Secure Shell) 是一种加密的网络传输协议，用于在不安全的网络中为网络服务提供安全的传输环境。\n接下来我们将会创建公钥、私钥，用于ssh加密传输\n第1步： 创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\nssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n第2步： 登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：\n点“Add Key”，你就应该看到已经添加的Key：\n为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。\n当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了\n最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。\n如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。\n\n        \n          添加远程仓库\n      首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库\n在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库\n目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：\ngit remote add origin git@github.com:HaoGuangLiang/learngit.git\n\n请千万注意，把上面的HaoGuangLiang替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。\n添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库，比如我们现在关联的是github仓库我们也可以改成github。\n我们在推送之前先修改一下主分支的名字为main，因为现在github创建的仓库默认分支就是main：\ngit branch -m main\n\n下一步，就可以把本地库的所有内容推送到远程库上：\ngit push -u origin main\n\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支main推送到远程。\n由于远程库是空的，我们第一次推送main分支时，加上了-u参数，Git不但会把本地的main分支内容推送的远程新的main分支，还会把本地的main分支和远程的main分支关联起来，在以后的推送或者拉取时就可以简化命令。\n推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：\n从现在起，只要本地作了提交，就可以通过命令：\ngit push origin main\n\n把本地main分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\n\n        \n          SSH警告\n      当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：    The authenticity of host ‘github.com (xx.xx.xx.xx)’ can’t be established.    RSA key fingerprint is xx.xx.xx.xx.xx.    Are you sure you want to continue connecting (yes&#x2F;no)?\n这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。\nGit会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：    Warning: Permanently added ‘github.com’ (RSA) to the list of known hosts.\n这个警告只会出现一次，后面的操作就不会有任何警告了。\n如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致\n\n        \n          删除远程库\n      如果关联远程仓库的时候地址写错了，或者就是想删除远程库关联，可以用git remote rm &lt;name&gt;命令。使用前，建议先用git remote -v查看远程库信息：\ngit remote -v\n\n然后，根据名字删除，比如删除origin：\ngit remote rm origin\n\n此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。\n\n        \n          从远程库克隆\n      上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。\n现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。\n首先，登陆GitHub，创建一个新的仓库，名字叫gitskills\n然后我们根据github的提示生成一个README.md文件\n现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库\ngit clone git@github.com:HaoGuangLiang/learngit.git\n\n注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件\n如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。\n你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n\n        \n          分支管理\n      分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n接下来我们进入实战\n首先，我们创建dev分支，然后切换到dev分支：\ngit checkout -b dev\n\ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\ngit branch devgit checkout dev\n\n然后，用git branch命令查看当前分支：\ngit branch* dev  master\n\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\n然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：\nCreating a new branch is quick.\n\n然后提交：\ngit add readme.txt git commit -m &quot;branch test&quot;\n\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\n现在，我们把dev分支的工作成果合并到master分支上：\ngit merge dev\n\ngit merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\n合并完成后，就可以放心地删除dev分支了：\ngit branch -d dev\n\n删除后，查看branch，就只剩下master分支了：\ngit branch* master\n\n\n        \n          switch\n      我们注意到切换分支使用git checkout &lt;branch&gt;，而前面讲过的撤销修改则是git checkout -- &lt;file&gt;，同一个命令，有两种作用，确实有点令人迷惑。\n实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支：\n创建并切换到新的dev分支，可以使用：\ngit switch -c dev\n\n直接切换到已有的master分支，可以使用：\ngit switch master\n\n使用新的git switch命令，比git checkout要更容易理解。\n\n        \n          解决冲突\n      下面我们将用一个例子来讲解冲突的产生，以及解决\n先创建一个新分支feature\ngit switch -c featureSwitched to a new branch &#x27;feature&#x27;\n\n修改readme.txt文件，在最后面加一行\nbranch feature add one row\n\n在feature上提交\ngit add readme.txtgit commit -m &quot;branch feature add&quot;On branch featurenothing to commit, working tree clean\n\n然后，切换到main分支\ngit switch main\n\n在main分支我们修改一下readme.txt的文件内容，我们直接在最后面加一行\nbranch main add one row\n\n然后我们提交修改\ngit add readme.txtgit commit -m  &quot;branch main add&quot;On branch mainYour branch is ahead of &#x27;origin/main&#x27; by 9 commits.  (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean\n\n然后我们对两个分支进行合并\ngit merge featureAuto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result.\n\ngit直接提示我们出现冲突，需要我们去确认文件的具体内容，此时我们打开readme.txt文件看一下\nGit is a distributed version control system.Git is free software distributed under the GPL.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADbranch main add one row=======branch feature add one row&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature\n\nGit用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：\nGit is a distributed version control system.Git is free software distributed under the GPL.branch main add one rowbranch feature add one row\n\n提交结果\ngit add readme.txtgit commit -m &quot;confirm merge result&quot;[main 6158a1f] confirm merge result\n\n现在我们就解决冲突，并完成了分支的合并，我们可以使用带参数的git log也可以看到分支的合并情况\ngit log --graph --pretty=oneline --abbrev-commit*   6158a1f (HEAD -&gt; main) confirm merge result|\\| * 39935b2 (feature) branch feature add* | 828a816 branch main add|/\n\n–graph查看分支合并图分支合并图\n–abbrev-commit 缩短hash的显示\n最后我们删除掉feature分支，就大功告成了\ngit branch -d feature\n\n\n        \n          分支管理策略\n      \n        \n          禁用快速合并\n      通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward\ngit merge --no-ff -m &quot;merge with no-ff&quot; dev\n\n因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。\n我们对比一下区别\ngit log --graph --pretty=oneline --abbrev-commit*   eaf1113 (HEAD -&gt; main) merge-no-ff|\\| * 58777ac (dev) second add hgl|/* 71f9893 add hgl\n\n71f9893：快速合并显示\n58777ac：禁用Fast forward模式合并显示\n\n        \n          分支策略\n      在实际开发中，我们应该按照几个基本原则进行分支管理：\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n所以，团队合作的分支看起来就像这样：\n\n\n        \n          Bug分支\n      在开发过程中，我们很有可能突然遇到bug，但是当前代码还未完成不能提交的情况，git提供了解决方案，可以先把当前修改储存起来，等bug修复后，再恢复现场。\n储存当前工作现场\ngit stashSaved working directory and index state WIP on dev: f52c633 add merge\n\n查看储存记录\ngit stash liststash@&#123;0&#125;: WIP on dev: f52c633 add merge\n\n恢复现场，有两种方式，方式一恢复现场，储存记录还在，可以再删除储存记录\n# 恢复现场，保留储存记录git stash apply# 删除储存记录git stash drop\n\n方式二恢复并删除\ngit stash pop\n\n如果储存了多次现场，我们也可以恢复指定现场\n# 恢复现场git stash apply stash@&#123;0&#125;# 恢复现场并删除储存的现场记录git stash pop stash@&#123;0&#125;\n\n我们在bug分支修复完后会合并到主分支并提交，这时候我们的dev分支也是有bug的，总不能在修复一次吧，git提供了一个命令解决这个问题，可以从其他分支复制过来一个特定的版本\ngit cherry-pick 4c805e2\n\n修复流程主要是这样，假设在dev开发功能\n\n在dev分支储存当前修改记录\n\n切换到主分支\n\n创建bug分支\n\n修复问题，并提交\n\n切换到主分支\n\n合并bug分支\n\n切换到dev分支\n\n从主分支复制修复版本到dev分支\n\n恢复现场\n\n\n\n        \n          删除分支\n      比如删除分支dev\ngit branch -d dev\n\n但是有时候我们删除分支时，发薪分支内容未合并，此时使用上面命令就删除不了了，提示我们该分支还未合并，不过我们可以使用下面命令强制删除分支\nbit branch -D dev\n\n\n        \n          多人协作\n      查看远程库信息，远程仓库的默认名称是origin\ngit remote\n\n用git remote -v显示更详细的信息\ngit remote -vorigin  git@github.com:michaelliao/learngit.git (fetch)origin  git@github.com:michaelliao/learngit.git (push)\n\n\n        \n          推送分支\n      推送master分支到远程仓库\ngit push origin master\n\n推送dev分支到远程仓库\ngit push origin dev\n\nmaster分支是主分支，因此要时刻与远程同步；\ndev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\nbug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\nfeature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n        \n          抓取分支\n      查看远程仓库信息\ngit remote\n\n查看远程仓库详细信息\ngit remote -vorigin  git@github.com:michaelliao/learngit.git (fetch)origin  git@github.com:michaelliao/learngit.git (push)\n\n上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n克隆分支\ngit clone git@github.com:michaelliao/learngit.git\n\n拉取最新的提交\ngit pull\n\n拉取代码如果没有和远程仓库建立链接可以使用下面命令建立链接\ngit branch --set-upstream-to=origin/&lt;branch name&gt; dev\n\n推送分支\ngit push\n\n推送分支可能会出现冲突的问题，这时候就需要先拉取代码，然后解决冲突后重新提交就可以了\n\n查看远程库信息，使用git remote -v；\n本地新建的分支如果不推送到远程，对其他人就是不可见的；\n从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；\n在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；\n建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；\n从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。\n\n\n        \n          Rebase这个不理解 ，待完善\n      \n        \n          标签管理\n      对某个commitId 打一个标签，方便以后直接根据标签内找到想要的版本\n打标签流程，首先切换到想要打标签的分支\n使用命令对最新的一条提交记录打标签\ngit tag v1.0\n\n指定commit id打标签\ngit tag v0.9 &lt;commit id&gt;\n\n查看分支内已打标签\ngit tagv0.9v1.0\n\n注意，标签不是按时间顺序列出，而是按字母排序的\n查看标签信息\ngit show v0.9commit c4b26c398338e3c3e8d9b24ce581007b8b2ceb21 (HEAD -&gt; main, tag: v1.0, origin/main, origin/HEAD)Author: HaoGuangLiang &lt;h15737811708@163.com&gt;Date:   Mon Dec 29 17:42:09 2025 +0800    add1diff --git a/readme.txt b/readme.txtindex fc4672e..c1c8391 100644--- a/readme.txt+++ b/readme.txt@@ -3,3 +3,4 @@ Git is free software distributed under the GPL. repair BUG My modify alredy commit; My modify not commit;+add 1\\ No newline at end of file\n\n创建带有说明的标签，用-a指定标签名，-m指定说明文字\ngit tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb\n\n\n        \n          操作标签\n      如果标签打错了，也可以删除：\ngit tag -d v0.1Deleted tag &#x27;v0.1&#x27; (was 1881005)\n\n标签是存储在本地的，不过也可以推动到远程仓库\n单个推送标签到远程仓库\ngit push origin v1.0Total 0 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)To github.com:HaoGuangLiang/learngit.git * [new tag]         v1.0 -&gt; v1.0\n\n一次性推送全部尚未推送到远程的本地标签\ngit push origin --tagsTotal 0 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)To github.com:HaoGuangLiang/learngit.git * [new tag]         v0.9 -&gt; v0.9 * [new tag]         v1.1 -&gt; v1.1\n\n如果标签已经被推送到远程，想要删除可以这样操作，先删除本地标签，再删除远程标签\n# 删除本地标签git tag -d v0.9Deleted tag &#x27;v0.9&#x27; (was 63d91b3)# 删除远程标签git push origin :refs/tags/v0.9To github.com:HaoGuangLiang/learngit.git - [deleted]         v0.9\n\n\n        \n          使用GitHub\n      再GitHub上如果想要参与GitHub开源项目应该如何操作呢\n\n首先找到想要参与的项目，Fork一下，就可以将项目复制到自己的远程仓库\n\n然后从自己的远程仓库拉取代码\n\n修改、提交到自己远程仓库\n\n然后使用pull request给官方发送推送请求，当然官方接不接受就不一定了。\n\n\n\n        \n          使用Gitee\n      使用前提：\n\n需要设置gitee的SSH公钥\n\n在Gitee中创建一个远程仓库，名字最好喝本地仓库一样\n\n\n\n        \n          本地仓库关联Gitee远程仓库\n      git remote add origin git@gitee.com:liaoxuefeng/learngit.gitfatal: remote origin already exists.\n\n如果提示远程仓库存在，我们可以先删除掉重新使用上面命令关联\n# 查看远程仓库git remote -vorigin    git@github.com:michaelliao/learngit.git (fetch)origin    git@github.com:michaelliao/learngit.git (push)# 取消关联远程仓库git remote rm origin# 重新关联git remote add origin git@gitee.com:liaoxuefeng/learngit.git\n\n\n        \n          如何关联多个远程仓库\n      举例说明，我们同时关联GitHub和Gitee，关键就在于我们改变了远程仓库的名字，把origin改成github、gitee\n# 关联GitHub仓库git remote add github git@github.com:michaelliao/learngit.git# 关联Gitee仓库git remote add gitee git@gitee.com:liaoxuefeng/learngit.git\n\n接下来我们就可以推送代码了\n# 推送到githubgit push github main# 推送到giteegit push gitee main\n\nGitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：https://gitee.com/liaoxuefeng/learngit，创建一个your-gitee-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在Gitee和GitHub做双向同步。\n\n        \n          自定义Git\n      \n        \n          忽略特殊文件\n      .gitignore文件用于忽略同级和子目录下的文件，可以在项目中放置多个。\n忽略文件的原则是：\n\n忽略操作系统自动生成的文件，比如缩略图等；\n忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；\n忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。\n\n忽略文件语法，在.gitignore文件中\n# 使用全名忽略a.txtb.txt# 可以忽略a.pyc、b.pyc、b.pyo、b.pyd等等文件*.py[cod]# 需要忽略的文件直接在匹配规则前加！# 不要忽略App.classs!App.class# 不要忽略a.txa、a.txb、b.txa等等文件  !*.tx[ab]\n\n\n        \n          配置别名\n      可以给复杂的常用的一些命令起一个别名\n案例1，给status命令起别名\ngit config --global alias.st status\n\n这样我们就可以使用   git st代替status\n案例2：\ngit config --global alias.last &quot;log -1&quot;\n\n这样我们就能够使用git last代替git log -1了\n当然，我们还能给更加复杂且长的命令起别名\n\n        \n          配置文件\n      配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。\n使用了–global时配置文件在当前用户主目录下的.gitconfig\n未使用-global时配置文件就在当前仓库的.git&#x2F;config文件中\n[core]    repositoryformatversion = 0    filemode = false    bare = false    logallrefupdates = true    symlinks = false    ignorecase = true[remote &quot;gitee&quot;]    url = https://gitee.com/hao_guang_liang/learngit.git    fetch = +refs/heads/*:refs/remotes/gitee/*[remote &quot;github&quot;]    url = git@github.com:HaoGuangLiang/learngit.git    fetch = +refs/heads/*:refs/remotes/github/*[alias]    last = log -1\n\ngit命令一个别名只能设置一个命令，如果已经设置的情况下可以到相应的配置文件中先删除已经设置的别名，在设置，或直接在配置文件中设置都可以。\n\n        \n          搭建Git服务器\n      搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。\n","categories":["版本控制","git"],"tags":["git"]},{"title":"使用Git遇到的一些问题和解决方案","url":"/2026/01/08/%E4%BD%BF%E7%94%A8Git%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%BF%E7%94%A8Git%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"\n        \n          fatal: refusing to merge unrelated histories\n      第一次从远程分支拉取或合并代码时提示了这个错误fatal: refusing to merge unrelated histories，中文意思是致命的：拒绝合并不相关的历史。这个错误通常发生在尝试合并两个没有共同提交历史的 Git 仓库时（例如，git pull 或 git merge）\n原因分析:\n\n两个分支&#x2F;仓库的历史完全不相关（比如一个是从空仓库初始化，另一个是从其他仓库克隆的）。\nGit 默认不允许合并这样的分支，以防止意外覆盖代码。\n\n在 git pull 或 git merge 时加上 --allow-unrelated-histories 参数：\ngit pull origin main --allow-unrelated-histories # 或 git merge other-branch --allow-unrelated-histories\n\n适用场景：你明确知道两个仓库的历史不同，但仍想合并（例如，从不同来源合并代码）\n","categories":["一级分类","二级分类"],"tags":["标签不分层级","都是同级"]},{"title":"Git常用命令","url":"/2026/01/09/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"","categories":["一级分类","二级分类"],"tags":["标签不分层级","都是同级"]},{"title":"IDEA中使用Git","url":"/2026/01/13/%E5%9C%A8IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Git/%E5%9C%A8IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Git/","content":"\n        \n          设置Git远程仓库\n      检出项目方式\n使用git对项目进行版本控制\n如何将文件忽略\n如何追踪文件和取消追踪文件\n远程仓库的一些陪孩子\n\n        \n          快捷键\n      \n + \n +  + \nAlt + O 打开提交窗口，查看未追踪、未提交的文件\n","categories":["版本控制","git","IDEA"],"tags":["git","IDEA"]},{"title":"炒股基础知识","url":"/2026/01/21/%E7%82%92%E8%82%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%92%E8%82%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"\n        \n          基础知识\n      \n        \n          新手开户、炒股\n      \n        \n          入市要求与准备\n      身份要求：必须是中国大陆年满 18 周岁的公民，需准备身份证、本人名下银行卡（工农中建交等主流银行均可）。\n资金要求：A 股开户无资金门槛，新手建议用闲钱（亏了不影响生活的钱），首笔投入不超过可投资资产的 20%，严禁用杠杆、网贷炒股。\n知识储备：先搞懂基础概念（股票代码、涨停跌停、T+1 交易、主板 &#x2F; 创业板 &#x2F; 科创板区别），避免盲目跟风。\n\n        \n          核心步骤：开通证券账户\n      国内炒股必须通过持牌证券公司开户，主流渠道是证券公司 APP，全程 5-10 分钟搞定。\n选证券公司：\n优先选规模大、佣金低、APP 好用的头部券商（比如华泰证券、中信证券、东方财富、同花顺等）。\n佣金费率：现在普遍是 万 1.2~ 万 2.5（买卖都收，最低 5 元起），开户前可在 APP 内确认费率，避免高佣金。\n开户操作（以手机 APP 为例）\n下载对应券商 APP，注册并登录。\n点击 “开户”，按提示上传身份证正反面，确保照片清晰无遮挡。\n完成人脸识别（需本人出镜，光线充足），核对身份信息无误后提交。\n选择开户营业部（系统默认即可，不影响交易），勾选要开通的市场：\n\n必选：沪 A 账户 + 深 A 账户（能买沪深主板股票）；\n\n可选：创业板（需满足 2 年交易经验 + 20 个交易日日均资产≥10 万）、科创板（2 年经验 + 50 万资产）、北交所（2 年经验 + 50 万资产）。\n\n\n绑定本人银行卡，设置交易密码和资金密码（两个密码建议分开设置，记牢）。\n完成风险测评问卷（如实填写，系统会评估你的风险承受能力），提交后等待审核（一般 1-3 个工作日，多数券商当天出结果）。\n\n        \n          掌握 A 股核心交易规则\n      \n\n\n规则项\n具体要求\n\n\n\n交易时间\n工作日 9:30-11:30，13:00-15:00；9:15-9:25 是集合竞价时间（可挂单，9:25 撮合成交）\n\n\n交易制度\nT+1：当天买的股票，次日才能卖\n\n\n涨跌幅限制\n主板 ±10%；创业板 &#x2F; 科创板 ±20%；ST 股 ±5%\n\n\n最小交易单位\n1 手 &#x3D; 100 股，买入必须是 100 股的整数倍，卖出可以是零散股\n\n\n\n        \n          入金（把钱转到证券账户）\n      开户审核通过后，打开券商 APP，找到 “银证转账” 功能。\n选择 “银行转证券”，输入转账金额和银行卡密码，确认后资金会实时到账。\n\n        \n          实盘交易操作\n      选股：在 APP 搜索股票代码 &#x2F; 名称（比如贵州茅台 600519），查看基本面（财报、市盈率）、技术面（K 线图）。\n挂单买入：进入个股详情页，点击 “买入”，输入价格和数量（必须是 100 股整数倍），选择 “限价委托”（按你设定的价格成交）或 “市价委托”（按当前市场价格成交），确认下单。\n持仓与卖出：买入后，在 “持仓” 里查看股票盈亏；想卖出时，点击 “卖出”，输入数量，挂单等待成交即可。\n提示：在正式交易前建议新手先试用模拟炒股功能练练手，很多券商 APP（如东方财富）有模拟炒股功能，可免费领取模拟资金，熟悉选股、挂单、止盈止损流程，练 1-3 个月再实盘。\n\n        \n          新手必看风控要点\n      不追涨杀跌：避免看到股票涨了就盲目买入，跌了就恐慌卖出。分散持仓：不要把所有钱买一只股票，新手建议持仓 3-5 只不同行业的股票。设止盈止损：比如盈利 10% 就卖出止盈，亏损 5% 就止损离场，避免被套。不碰不懂的标的：不熟悉的行业、题材股尽量不碰，远离 ST 股、退市风险股。\n\n        \n          常用工具与学习渠道\n      行情工具：同花顺、东方财富 APP（看实时行情、资讯）；学习渠道：证监会官网（查规则）、雪球（看投资者分析）、券商 APP 内的新手学堂。\n\n        \n          行业黑话\n      \n        \n          免五是什么\n      普通规则：券商收取的佣金（买卖股票时的手续费），一般按成交金额的万分之几算，但有个最低 5 元的门槛。比如你买了 1 万元股票，佣金万分之 1.5 就是 1.5 元，但实际会按 5 元收取。\n免五：就是取消这个 “最低 5 元” 的限制，该收多少就收多少。比如你买 1 万元股票，佣金万分之 1.5 就只收 1.5 元，这样小资金高频交易能省不少钱。\n\n        \n          不熟悉的行业、题材股尽量不碰，远离 ST 股、退市风险股。\n      不碰不懂的行业、题材股：\n比如你是程序员，可能能看懂互联网、软件公司的业务逻辑；但如果你完全不懂新能源电池的技术原理、医药行业的研发流程，就别跟风买这些行业的股票。\n题材股就是那些靠 “概念” 炒作的股票（比如突然炒 “人工智能”“元宇宙” 概念），这些股票往往没什么实际业绩支撑，涨得快跌得更快，你看不懂它为啥涨，就很容易在高点接盘，最后被套。\n远离 ST 股、退市风险股：\nST 股：股票名字前面加了 “ST”，就说明这家公司连续两年亏损，或者财务出了大问题，被交易所 “戴帽警告” 了。这类股票每天的涨跌幅限制只有 ±5%，而且随时可能继续亏损，甚至退市。\n退市风险股：比 ST 股更危险，名字里可能带 “*ST”，意思是这家公司已经快撑不下去了，如果再亏一年，就会被踢出股市。一旦退市，你手里的股票就会变成一堆废纸，基本卖不出去，本金大概率血本无归。\n简单总结：炒股别贪 “看不懂的暴利”，新手就从自己熟悉的行业、业绩稳定的公司下手，那些看着就有问题的股票，直接绕着走。\n\n        \n          做T是什么\n      做 T 是 A 股里的一种短线交易技巧，因为 A 股是T+1（当天买的股票不能当天卖），所以做 T 的核心就是利用手里已有的持仓，在同一天内先卖后买（或先买后卖），来赚取日内差价，降低持仓成本。\n\n        \n          做 T 的两种常见方式\n      正 T（先卖后买）\n\n操作逻辑：手里已经有某只股票，开盘后股价冲高时先卖出一部分，等股价回落再低价买回。\n举例：你持有 1000 股某股，成本价 10 元。今天开盘后涨到 11 元，你先卖出 500 股；等股价跌到 10.5 元时，再买回 500 股。\n结果：你的持仓还是 1000 股，但手里多了 (11-10.5)×500=250元 现金，持仓成本也被拉低了。\n\n倒 T（先买后卖）\n\n操作逻辑：手里已经有某只股票，开盘后股价下跌时先买入一部分，等股价反弹再卖出相同数量。\n\n举例：你持有 1000 股某股，成本价 10 元。今天开盘后跌到 9.5 元，你先买入 500 股；等股价涨到 10 元时，再卖出 500 股。\n\n结果：你的持仓还是 1000 股，同样赚了 (10-9.5)×500=250元 现金，持仓成本降低。\n\n\n\n        \n          做 T 的关键前提\n      \n必须有底仓：手里得先持有这只股票，才能在当天做买卖操作。\n判断日内波动：需要能大致判断股票当天的高低点，否则容易 “卖飞” 或 “套牢”。\n手续费成本：频繁做 T 会增加佣金、印花税等费用，“免五” 账户会更划算。\n\n\n        \n          新手做 T 避坑提醒\n      \n别贪心：目标是赚 1-2 个点的差价就走，不要追求满仓做 T。\n只做熟悉的股票：对自己持仓的股性（波动规律）越熟悉，做 T 成功率越高。\n大盘暴跌时别硬做：如果大盘整体下跌，个股可能一路阴跌，容易导致买入后无法卖出，反而被套。\n控制仓位：每次做 T 的仓位建议不超过底仓的 50%，避免风险过大\n\n","categories":["炒股","基础知识"],"tags":["新手炒股","炒股基础知识"]}]